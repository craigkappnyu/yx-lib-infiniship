package br.com.yuiti.lab.infiniship;

import flash.display.MovieClip;
import flash.display.Shape;
import flash.display.Sprite;

/**
 * InfiniShip | Haxe/OpenFl :: A procedural spaceship generator
 * ======================================================================
 * 
 * This is a remake of Dave Bollinger's "Pixel Spaceships", remade and 
 * fully commented.
 * 
 * I tried to organize things inside and comment/explain everything, but I'm 
 * a little bit bad with programming so, sorry if I messed up something.
 * 
 * The original script was made for Processing, in 2006, by Dave. But this 
 * version has also used "mtheall" HTML5 Canvas (from 2013) version as reference 
 * for some structure and methods.
 * 
 * This version is intended to work the same way as Bollinger's original script, 
 * and it tries to follow the same rules for the ship's cell grid.
 * 
 * NOTE: Some of the creative output (images) generated by this script remains 
 * property of Dave Bollinger, as this script follows his basic concept. Even 
 * though the possible combination of ships is huge, Dave still has copyright 
 * over his artistic output, so use this carefully.
 * 
 * You are welcome (and highly encouraged) to fork, remix, create your 
 * own way to generate sprites and use this as reference to build your own 
 * generator. :)
 * 
 * @author Fabio Y. Goto <lab@yuiti.com.br>
 */
class InfiniShip extends Sprite
{
    /* PRIVATE VARIABLES
     * ====================================================================== */
    
    /**
     * Empty cell flag.
     */
    private var S_EMPTY:Int = 0;
    
    /**
     * Solid cell flag.
     */
    private var S_SOLID:Int = 1;
    
    /**
     * Main body cell flag.
     */
    private var S_SHAPE:Int = 2;
    
    /**
     * Cockpit cell flag.
     */
    private var S_CABIN:Int = 3;
    
    /**
     * Ship width, in pixels.
     */
    private var SHIP_W:Int = 12;
    
    /**
     * Ship height, in pixels.
     */
    private var SHIP_H:Int = 12;
    
    /**
     * Array containing saturation values, to be used when defining colors.
     */
    private var sats:Array<Int> = [
        40, 60, 80, 100, 80, 60, 80, 100, 120, 100, 80, 60
    ];
    
    /**
     * Array containing brightness values, to be used when defining colors.
     */
    private var bris:Array<Int> = [
        40, 70, 100, 130, 160, 190, 220, 220, 190, 160, 130, 100, 70, 40
    ];
    
    /**
     * Array containing the cell data for body cells in the ship's sprite.
     * 
     * Content defined inside the constructor.
     */
    private var solidCell:Array<Int>;
    
    /**
     * Array containing the cell data for cockpit cells in the ship's sprite.
     * 
     * Content defined inside the constructor.
     */
    private var shapeCell:Array<Int>;
    
    /**
     * Array containing the cell data for cockpit cells in the ship's sprite.
     * 
     * Content defined inside the constructor.
     */
    private var cabinCell:Array<Int>;
    
    /**
     * Main ship array, used when generating the ship, to define the ship's cells.
     */
    private var shipCell:Array<Int>;
    
    /**
     * Pseudo-random integer, to be used a seed when defining the ship's shape.
     * 
     * Content defined inside the constructor.
     */
    private var mainseed:Int;
    
    /**
     * Pseudo-random integer, to be used a seed when defining the ship's color.
     * 
     * Content defined inside the constructor.
     */
    private var clrsseed:Int;
    
    /**
     * Main ship containter.
     */
    private var ship:Shape;
    
    /**
     * Main ship wrapper. This is the object that will be added to the stage.
     */
    private var wrap:MovieClip;
    
    
    
    /* CONSTRUCTOR
     * ====================================================================== */
    public function new() 
    {
        // Initializing super constructor
        super();
        
        // Defining seeds
        mainseed = generateSeed();
        clrsseed = generateSeed();
        
        // Defining cell data
        solidCell = [
            cell(5, 2),  cell(5, 3),  cell(5, 4), 
            cell(5, 5),  cell(5, 9)
        ];
        shapeCell = [
            cell(4, 1),  cell(5, 1),  cell(4, 2),  cell(3, 3),   cell(4, 3), 
            cell(3, 4),  cell(4, 4),  cell(2, 5),  cell(3, 5),   cell(4, 5), 
            cell(1, 6),  cell(2, 6),  cell(3, 6),  cell(1, 7),   cell(2, 7), 
            cell(3, 7),  cell(1, 8),  cell(2, 8),  cell(3, 8),   cell(1, 9), 
            cell(2, 9),  cell(3, 9),  cell(4, 9),  cell(3, 10),  cell(4, 10), 
            cell(5, 10)
        ];
        cabinCell = [
            cell(4,6),  cell(5,6),  cell(4,7),  cell(5,7), 
            cell(4,8),  cell(5,8)
        ];
        
        // Generating ship
        generateShip();
    }
    
    
    
    /* SEED GENERATION AND NUMBER OPERATIONS 
     * ====================================================================== */
    
    /**
     * Calculates the pixel index value.
     * 
     * @param x
     * @param y
     * @return
     */
    private function cell(x:Int, y:Int):Int 
    {
        return (y * SHIP_W) + x;
    }
    
    /**
     * Generates the seeds for defining the ship's shape and color.
     * 
     * It tries to use something similar to the original script's seed generator.
     * 
     * @return
     */
    private function generateSeed():Int 
    {
        return Math.floor(Math.random() * 4 * 1024 * 1024 * 1024);
    }
    
    /**
     * Converts a decimal number to its HEX counterpart.
     * 
     * Restricted from 0 to 255, if input is lower than 0 it will be changed 
     * to 0, and if bigger than 255 will be changed to 255.
     * 
     * @param nums
     * @return
     */
    private function dechex(nums:Int):String 
    {
        // Checking if lower than 0 or bigger than 255
        if (nums < 0) nums = 0;
        if (nums > 255) nums = 255;
        // Converting to string and returning
        return StringTools.hex(nums, 2);
    }
    
    
    
    /* COLORS
     * ====================================================================== */
    
    /**
     * Converts the HSV (Hue, Saturation and Brightness) values from a color 
     * into its RGB counterpart, returning them in a formatted object, with its 
     * RGB values.
     * 
     * @param h
     * @param s
     * @param v
     * @return
     */
    private function HSVRGB(h:Float, s:Float, v:Float):Int
    {
        // Declaring internal variables
        var r, g, b, i, f, p, q, t;
        // If saturation equals 0, returns a shade of gray
        if (s == 0) {
            // Generating shade of gray for all RGB channels
            var gray = dechex(Math.floor(v * 255));
            // Returning values
            return Std.parseInt("0x" + gray + gray + gray);
        }
        // Defining color values
        i = Math.floor(h * 6);
        f = h * 6 - i;
        p = v * (1 - s);
        q = v * (1 - f * s);
        t = v * (1 * (1 - f) * s);
        // Defining RGB values
        switch (i % 6) {
            case 1:
                r = q;
                g = v;
                b = p;
            case 2:
                r = p;
                g = v;
                b = t;
            case 3:
                r = p;
                g = q;
                b = v;
            case 4:
                r = t;
                g = p;
                b = v;
            case 5:
                r = v;
                g = p;
                b = q;
            default:
                r = v;
                g = t;
                b = p;
        }
        // Returning color
        return Std.parseInt(
            "0x" 
            + dechex(Math.floor(r * 255))
            + dechex(Math.floor(g * 255))
            + dechex(Math.floor(b * 255))
        );
    }
    
    /**
     * Defines the colors for a determined pixel, on the ship's body. Returns 
     * it as an integer corresponding to the RGB values of the defined color.
     * 
     * @param x
     * @param y
     * @return
     */
    private function shapeColor(x:Int, y:Int):Int 
    {
        // Defining saturation
        var s:Float = sats[y] / 255.0;
        // Defining brightness
        var b:Float = bris[x] / 255.0;
        // Defining hue
        var h:Float;
        if (y < 6) {
            h = (clrsseed >> 8) & 0xFF;
        } else if (y < 9) {
            h = (clrsseed >> 16) & 0xFF;
        } else {
            h = (clrsseed >> 24) & 0xFF;
        }
        // Returning
        return HSVRGB(360 * h / 256, s, b);
    }
    
    /**
     * Defines the colors for a determined pixel, on the ship's cockpit. Returns 
     * it as an integer corresponding to the RGB values of the defined color.
     * 
     * @param x
     * @param y
     * @return
     */
    private function cabinColor(x:Int, y:Int):Int 
    {
        // Defining saturation
        var s:Float = sats[y] / 255.0;
        // Defining brightness
        var b:Float = (bris[x] + 40) / 255.0;
        // Defining hue
        var h:Float = clrsseed & 0xFF;
        // Returning
        return HSVRGB(360 * h / 256, s, b);
    }
    
    
    
    /* SHIP GENERATION
     * ====================================================================== */
    
    /**
     * Generates a single ship and adds it to the stage.
     */
    private function generateShip():Void 
    {
        // Initializing ship sprite
        ship = new Shape();
        
        // Initializing sprite wrapper
        wrap = new MovieClip();
        
        // Initializing ship cell array
        shipCell = new Array<Int>();
        
        // Marking all cells as empty, to start
        var area:Int = SHIP_W * SHIP_H;
        for (i in 0...area) {
            shipCell[i] = S_EMPTY;
        }
        // Initializing always solid cells
        for (i in 0...Lambda.count(solidCell)) {
            shipCell[solidCell[i]] = S_SOLID;
        }
        
        // Marking body cells
        for (i in 0...Lambda.count(shapeCell)) {
            if ((mainseed & (1 << i)) > 0) {
                shipCell[shapeCell[i]] = S_SHAPE;
            } else {
                shipCell[shapeCell[i]] = S_EMPTY;
            }
        }
        
        // Marking the cockpit cells
        for (i in 0...Lambda.count(cabinCell)) {
            if ((mainseed & (1 << (Lambda.count(shapeCell) + i))) > 0) {
                shipCell[cabinCell[i]] = S_SOLID;
            } else {
                shipCell[cabinCell[i]] = S_CABIN;
            }
        }
        
        // Defining border cells
        for (y in 0...SHIP_H) {
            for (x in 0...Math.floor(SHIP_W / 2)) {
                // If the cell is a body cell
                if (shipCell[cell(x, y)] == S_SHAPE) {
                    // Top
                    if (y > 0 && shipCell[cell(x, y - 1)] == S_EMPTY) {
                        shipCell[cell(x, y - 1)] = S_SOLID;
                    }
                    // Left
                    if (x > 0 && shipCell[cell(x - 1, y)] == S_EMPTY) {
                        shipCell[cell(x - 1, y)] = S_SOLID;
                    }
                    // Right
                    if (
                        x < Math.floor(SHIP_W / 2) - 1 
                        && shipCell[cell(x + 1, y)] == S_EMPTY
                    ) {
                        shipCell[cell(x + 1, y)] = S_SOLID;
                    }
                    // Bottom
                    if (y < SHIP_H && shipCell[cell(x, y + 1)] == S_EMPTY) {
                        shipCell[cell(x, y + 1)] = S_SOLID;
                    }
                }
            }
        }
        
        // Drawing the pixels inside the shape object
        for (y in 0...SHIP_H) {
            for (x in 0...Math.floor(SHIP_W / 2)) {
                // If the current cell isn't an empty cell
                if (shipCell[cell(x, y)] != S_EMPTY) {
                    // Defining colors to paint the ship
                    if (shipCell[cell(x, y)] == S_SOLID) {
                        // Border/solid cell color
                        ship.graphics.beginFill(0x000000, 1);
                    } else if (shipCell[cell(x, y)] == S_SHAPE) {
                        // Defining body color
                        var tint:Int = shapeColor(x, y);
                        // Begin filling with the current color
                        ship.graphics.beginFill(tint, 1);
                    } else if (shipCell[cell(x, y)] == S_CABIN) {
                        // Defining cockpit color
                        var tint:Int = cabinColor(x, y);
                        // Begin filling with the current color
                        ship.graphics.beginFill(tint, 1);
                    }
                    // Drawing the pixel
                    ship.graphics.drawRect(x, y, 1, 1);
                    // Drawing the mirrored pixel
                    ship.graphics.drawRect(SHIP_W - x - 1, y, 1, 1);
                }
            }
        }
        
        // Wrapping the ship and adjusting position (centering in x0, y0)
        wrap.addChild(ship);
        ship.x = -6;
        ship.y = -6;
        
        // Adding it to the stage
        addChild(wrap);
    }
}
