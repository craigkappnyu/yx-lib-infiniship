<?php
/**
 * InfiniShip | PHP :: A procedural spaceship generator
 * ======================================================================
 * 
 * This is a remake of Dave Bollinger's "Pixel Spaceships", remade and 
 * fully commented.
 * 
 * I tried to organize things inside and comment/explain everything, but I'm 
 * a little bit bad with programming so, sorry if I messed up something.
 * 
 * The original script was made for Processing, in 2006, by Dave. But this 
 * version has also used "mtheall" HTML5 Canvas (from 2013) version as reference 
 * for some structure and methods.
 * 
 * This version is intended to work the same way as Bollinger's original script, 
 * and it tries to follow the same rules for the ship's cell grid. Though I feel 
 * that the colors are a bit different (more saturation in this one).
 * 
 * I've added the following options:
 * - Use the original seed generator or a smaller seed (which renders things 
 * a little bit differently);
 * - Render everything monochrome;
 * - Choose if you want a transparent background or not;
 * - Return a single ship as a base64 encoded PNG;
 * - Return a sprite sheet as a base64 encoded PNG;
 * - Return the ship as an image resource, so you can save it in any format;
 * 
 * NOTE: Some of the creative output (images) generated by this script remains 
 * property of Dave Bollinger, as this script follows his basic concept. Even 
 * though the possible combination of ships is huge, Dave still has copyright 
 * over his artistic output, so use this carefully.
 * 
 * You are welcome (and highly encouraged) to fork, remix, create your 
 * own way to generate sprites and use this as reference to build your own 
 * generator. :)
 * 
 * @author Fabio Y. Goto <lab@yuiti.com.br>
 */
class InfiniShip 
{
    # CONSTANTS 
    # ====================================================================== #
    
    /**
     * Empty cell flag.
     * @var int
     */
    const S_EMPTY = 0;
    
    /**
     * Solid cell flag.
     * @var int
     */
    const S_SOLID = 1;
    
    /**
     * Main body cell flag.
     * @var int
     */
    const S_SHAPE = 2;
    
    /**
     * Cockpit cell flag.
     * @var int
     */
    const S_CABIN = 3;
    
    /**
     * Ship width, in pixels.
     * @var int
     */
    const SHIP_W = 12;
    
    /**
     * Ship height, in pixels.
     * @var int
     */
    const SHIP_H = 12;
    
    
    
    # VARIABLES
    # ====================================================================== #
    
    /**
     * Defined in the constructor. If <TRUE>, the class renders monochrome 
     * spaceships only. Default: <FALSE>.
     * @var bool
     */
    private $monochrome = false;
    
    /**
     * Defined by the constructor. If <TRUE>, the class will use something that 
     * works like the original seed generator. If <FALSE>, the class will use a 
     * smaller seed generator, which leads to different/simpler ships and colors. 
     * Default: <TRUE>.
     * @var bool
     */
    private $original = true;
    
    /**
     * Pseudo-random integer, set in the constructor, to be used a seed when 
     * defining the ship's shape.
     * @var int
     */
    private $mainseed;
    
    /**
     * Pseudo-random integer, set in the constructor, to be used a seed when 
     * defining the ship's color.
     * @var int
     */
    private $clrsseed;
    
    /**
     * Array containing saturation values, to be used when defining colors.
     * @var array
     */
    private $sats = array(
        40, 60, 80, 100, 80, 60, 80, 100, 120, 100, 80, 60
    );
    
    /**
     * Array containing brightness values, to be used when defining colors.
     * @var array
     */
    private $bris = array(
        40, 70, 100, 130, 160, 190, 220, 220, 190, 160, 130, 100, 70, 40
    );
    
    
    
    # CONSTRUCTOR
    # ====================================================================== #
    
    /**
     * Class constructor.
     * 
     * @param bool $original If uses, or not, the original seed generator
     * @param bool $monochrome If the generated ships will, or not, be monochrome
     */
    public function __construct($original = true, $monochrome = false) 
    {
        // Defining flags
        if ($original === false) $this->original = false;
        if ($monochrome === true) $this->monochrome = true;
        // Defining seeds
        $this->mainseed = $this->generateSeed();
        $this->clrsseed = $this->generateSeed();
    }
    
    
    
    # IMAGE GENERATION
    # ====================================================================== #
    
    /**
     * Generates a single ship and returns it as a base64 encoded image placed 
     * inside an image tag, ready to be printed.
     * 
     * Image dimensions: 16px X 16px.
     * 
     * @param bool $alpha If <TRUE>, uses a transparent background instead of white
     * @return string
     */
    public function makeShip($alpha = true) 
    {
        // Generate ship
        $ship = $this->generateSingle($alpha);
        
        // Initializing wrapper for the image (+4 to make it 16x16)
        $wrap = imagecreatetruecolor(self::SHIP_W + 4, self::SHIP_H + 4);
        
        // Verifying transparency on the image resource
        $wrap = $this->imageAlpha($wrap, $alpha);
        
        // Placing the resource inside the wrapper
        imagecopy($wrap, $ship, 2, 2, 0, 0, self::SHIP_W, self::SHIP_H);
        
        // Initialize output buffer, to capture the image
        ob_start();
        
        // Generating PNG
        imagepng($wrap);
        
        // Capturing into $data
        $data = ob_get_contents();
        
        // Cleaning buffer
        ob_end_clean();
        
        // Destroying image resources
        imagedestroy($wrap);
        imagedestroy($ship);
        
        // Returning img tag
        return '<img src="data:image/png;base64,'.base64_encode($data).'" alt="">';
    }
    
    /**
     * Generates a sprite sheet containing the specified number of ships on 
     * the horizontal (<$numX>) and vertical (<$numY>). The image size is 
     * automatically calculated and each ship occupies 16px square inside the 
     * image.
     * 
     * The default values for both horizontal and vertical quantities is 8, and 
     * the maximum is 64. This can be changed, though, if you have control over 
     * your server's memory limits.
     * 
     * The image is returned as a base64 encoded PNG image placed inside an 
     * image tag.
     * 
     * @param int $numsX Quantity of ships, horizontally (Default: 8, Max: 64)
     * @param int $numsY Quantity of ships, vertically (Default: 8, Max: 64)
     * @param bool $alpha If <TRUE>, uses a transparent background instead of white
     * @return string
     */
    public function makeMultiple($numX = 8, $numY = 8, $alpha = true) 
    {
        // Checking quantities
        $numX = (is_numeric($numX) && $numX < 64) ? $numX : 64;
        $numY = (is_numeric($numY) && $numY < 64) ? $numY : 64;
        
        // Calculating image dimentions
        $imgW = $numX * (self::SHIP_W + 4);
        $imgH = $numY * (self::SHIP_H + 4);
        
        // Creating resource
        $wrap = imagecreatetruecolor($imgW, $imgH);
        
        // Verifying transparency on the image resource
        $wrap = $this->imageAlpha($wrap, $alpha);
        
        // Defining initial X and Y to properly position the ships
        $posX = 2;
        $posY = 2;
        
        // Inserting ships inside the sprite sheet
        for ($y = 0; $y < $numY; $y++) {
            for ($x = 0; $x < $numX; $x++) {
                // Generating new seeds to avoid rendering same ship, in case 
                // <makeShip()> was used before this method
                $this->mainseed = $this->generateSeed();
                $this->clrsseed = $this->generateSeed();
                // Generating ship
                $ship = $this->generateSingle();
                // Placing the ship
                imagecopy(
                    $wrap, 
                    $ship, 
                    $posX, 
                    $posY, 
                    0, 
                    0, 
                    self::SHIP_W, 
                    self::SHIP_H
                );
                // Destroying image resource for the ship
                imagedestroy($ship);
                // Increasing X position, to properly place next ship
                $posX += (self::SHIP_W + 4);
            }
            // Resetting X position after internal loop ends
            $posX = 0;
            // Increasing Y position to properly place the next line
            $posY += (self::SHIP_H + 4);
        }
        
        // Initialize output buffer, to capture the image
        ob_start();
        
        // Generating PNG
        imagepng($wrap);
        
        // Capturing into $data
        $data = ob_get_contents();
        
        // Cleaning buffer
        ob_end_clean();
        
        // Destroying image resources
        imagedestroy($wrap);
        
        // Returning img tag
        return '<img src="data:image/png;base64,'.base64_encode($data).'" alt="">';
    }
    
    
    
    # SHIP GENERATION
    # ====================================================================== #
    
    /**
     * Generates a single ship and returns it as a true color image resource.
     * 
     * @param bool $alpha If <TRUE>, uses a transparent background instead of white
     * @return resource
     */
    public function generateSingle($alpha = true) 
    {
        // Alias for constants
        $w = self::SHIP_W;
        $h = self::SHIP_H;
        
        // Internal alias for seed
        $s = $this->mainseed;
        
        // Creating image resource
        $imgs = imagecreatetruecolor($w, $h);
        
        // Checking transparency
        $imgs = $this->imageAlpha($imgs, $alpha);
        
        // Defining cell data
        $cell = $this->cellValues();
        
        // Defining cell arrays
        $solid = $cell[0]; // Solid cells
        $shape = $cell[1]; // Body cells
        $cabin = $cell[2]; // Cockpit cells
        
        // Initializing ship cell array
        $ship = array();
        
        // Marking all cells as empty, to start
        for ($i = 0; $i < ($w * $h); ++$i) {
            $ship[$i] = self::S_EMPTY;
        }
        
        // Initializing always solid cells
        for ($i = 0; $i < count($solid); ++$i) {
            $ship[$solid[$i]] = self::S_SOLID;
        }
        
        // Marking body cells
        for ($i = 0; $i < count($shape); ++$i) {
            // Uses bitwise operations to determine which cells will be filled
            if ($s & (1 << $i)) {
                $ship[$shape[$i]] = self::S_SHAPE;
            } else {
                $ship[$shape[$i]] = self::S_EMPTY;
            }
        }
        
        // Marking the cockpit cells
        for ($i = 0; $i < count($cabin); ++$i) {
            if ($s & (1 << (count($shape) + 1))) {
                $ship[$cabin[$i]] = self::S_SOLID;
            } else {
                $ship[$cabin[$i]] = self::S_CABIN;
            }
        }
        
        // Defining border cells
        for ($y = 0; $y < $h; ++$y) {
            for ($x = 0; $x < ($w / 2); ++$x) {
                // If the current cell is part of the body
                if ($ship[$this->cell($x, $y)] == self::S_SHAPE) {
                    /**
                     * I broke the conditionals to keep the lines at a maximum 
                     * length, sorry if it looks confusing! >_<
                     */
                    // Top border
                    if (
                        $y > 0 
                        && $ship[$this->cell($x, $y - 1)] == self::S_EMPTY
                    ) {
                        $ship[$this->cell($x, $y - 1)] = self::S_SOLID;
                    }
                    // Left border
                    if (
                        $x > 0 
                        && $ship[$this->cell($x - 1, $y)] == self::S_EMPTY
                    ) {
                        $ship[$this->cell($x - 1, $y)] = self::S_SOLID;
                    }
                    // Right border
                    if (
                        $x < ($w / 2 - 1) 
                        && $ship[$this->cell($x + 1, $y)] == self::S_EMPTY
                    ) {
                        $ship[$this->cell($x + 1, $y)] = self::S_SOLID;
                    }
                    // Bottom border
                    if (
                        $y < ($h - 1) 
                        && $ship[$this->cell($x, $y + 1)] == self::S_EMPTY
                    ) {
                        $ship[$this->cell($x, $y + 1)] = self::S_SOLID;
                    }
                }
            }
        }

        // Coloring pixels inside the image resource
        for ($y = 0; $y < $h; ++$y) {
            for ($x = 0; $x < ($w / 2); ++$x) {
                // Only paint the ship if the current cell isn't empty
                if ($ship[$this->cell($x, $y)] != self::S_EMPTY) {
                    // Defining color values to paint
                    switch ($ship[$this->cell($x, $y)]) {
                        // Solid cell
                        case (self::S_SOLID):
                            // Solid cells are always black
                            $color = imagecolorallocatealpha(
                                $imgs, 
                                0, 
                                0, 
                                0, 
                                0
                            );
                            break;
                        // Body cell
                        case (self::S_SHAPE):
                            // Defining body color
                            if ($this->monochrome) {
                                // If monochrome is on, body is white
                                $color = imagecolorallocatealpha(
                                    $imgs, 
                                    255, 
                                    255, 
                                    255, 
                                    0
                                );
                            } else {
                                // Defining the RGB values
                                $color = $this->shapeColor($x, $y);
                                // Redefining color variable
                                $color = imagecolorallocatealpha(
                                    $imgs, 
                                    $color['r'], 
                                    $color['g'], 
                                    $color['b'], 
                                    0
                                );
                            }
                            break;
                        // Cockpit cell
                        case (self::S_CABIN):
                            // Defining cockpit color
                            if ($this->monochrome) {
                                // If monochrome is on, cockpit is white
                                $color = imagecolorallocatealpha(
                                    $imgs, 
                                    255, 
                                    255, 
                                    255, 
                                    0
                                );
                            } else {
                                // Defining the RGB values
                                $color = $this->cabinColor($x, $y);
                                // Redefining color variable
                                $color = imagecolorallocatealpha(
                                    $imgs, 
                                    $color['r'], 
                                    $color['g'], 
                                    $color['b'], 
                                    0
                                );
                            }
                            break;
                    }
                    // Defining pixel color
                    imagesetpixel($imgs, $x, $y, $color);
                    // Drawing it mirrored
                    imagesetpixel($imgs, $w - $x - 1, $y, $color);
                }
            }
        }

        // Returning resource
        return $imgs;
    }


    
    # COLORS AND IMAGE RESOURCE TREATMENT
    # ====================================================================== #
    
    /**
     * Converts the HSV (Hue, Saturation and Brightness) values from a color 
     * into its RGB counterpart, returning them in an associative array.
     * 
     * @param float $h Hue (0 ~ 360)
     * @param float $s Saturation (0 ~ 1)
     * @param float $v Value/Brightness (0 ~ 1)
     * @return array
     */
    private function HSVRGB($h, $s, $v) 
    {
        // If saturation is equal to zero, the returned color is a shade of gray
        if ($s == 0) {
            return array(
                'r' => (integer) floor($v * 255), 
                'g' => (integer) floor($v * 255), 
                'b' => (integer) floor($v * 255)
            );
        }
        // Building the values that'll define the final color
        $i = floor($h * 6);
        $f = ($h * 6) - $i;
        $p = $v * (1 - $s);
        $q = $v * (1 - $f * $s);
        $t = $v * (1 - (1 - $f) * $s);
        // Defining RGB values
        switch ($i % 6) {
            case 0:
                $r = $v;
                $g = $t;
                $b = $p;
                break;
            case 1:
                $r = $q;
                $g = $v;
                $b = $p;
                break;
            case 2:
                $r = $p;
                $g = $v;
                $b = $t;
                break;
            case 3:
                $r = $p;
                $g = $q;
                $b = $v;
                break;
            case 4:
                $r = $t;
                $g = $p;
                $b = $v;
                break;
            case 5:
                $r = $v;
                $g = $p;
                $b = $q;
                break;
        }
        // Returning the values
        return array(
            'r'  => (integer) floor($r * 255), 
            'g'  => (integer) floor($g * 255), 
            'b'  => (integer) floor($b * 255)
        );
    }
    
    /**
     * Returns an associative array, with the RGB values for the colors for a 
     * pixel in the desired coordinates, in the ship's body.
     * 
     * @param int $x X position of the pixel
     * @param int $y Y position of the pixel
     * @return array
     */
    private function shapeColor($x, $y) 
    {
        // Defining saturation
        $s = $this->sats[$y] / 255;
        // Defining brightness
        $v = $this->bris[$x] / 255;
        // Defining hue
        if ($y < 6) {
            $h = ($this->clrsseed >> 8) & 0xFF;
        } elseif ($y < 9) {
            $h = ($this->clrsseed >> 16) & 0xFF;
        } else {
            $h = ($this->clrsseed >> 24) & 0xFF;
        }
        // Returning RGB values
        return $this->HSVRGB(360 * $h / 256, $s, $v);
    }
    
    /**
     * Returns an associative array, with the RGB values for the colors for a 
     * pixel in the desired coordinates, in the ship's coockpit.
     * 
     * @param int $x X position of the pixel
     * @param int $y Y position of the pixel
     * @return array
     */
    private function cabinColor($x, $y) 
    {
        // Defining saturation
        $s = $this->sats[$y] / 255;
        // Defining brightness
        $v = ($this->bris[$x] + 40) / 255;
        // Defining hue
        $h = $this->clrsseed & 0xFF;
        // Returning RGB values
        return $this->HSVRGB(360 * $h / 256, $s, $v);
    }
    
    /**
     * Receives an image resource and checks whether it uses a transparent 
     * background or not, filling it the appropriate color and returns it.
     * 
     * @param resource $image An image resource
     * @param bool $alpha If <TRUE> (default), the image resource will have a 
     * transparent background, if <FALSE>, the image uses a white background
     * @return resource
     */
    private function imageAlpha($image, $alpha = true) 
    {
        // Checking transparency
        if ($alpha) {
            // Defining alpha blending
            imagealphablending($image, true);
            // Defining transparent color for background
            $transparency = imagecolorallocatealpha($image, 0, 0, 0, 127);
            // Fill the image
            imagefill($image, 0, 0, $transparency);
            // Saving alpha
            imagesavealpha($image, true);
        } else {
            // Define background as white
            $white = imagecolorallocatealpha($image, 255, 255, 255, 0);
            // Filling background
            imagefill($image, 0, 0, $white);
        }
        // Returning
        return $image;
    }
    
    
    
    # SEED GENERATION AND NUMBER OPERATIONS
    # ====================================================================== #
    
    /**
     * Calculates the pixel index value.
     * 
     * @param int $x X position of the pixel
     * @param int $y Y position of the pixel
     * @return int
     */
    private function cell($x, $y) 
    {
        return ($y * self::SHIP_W) + $x;
    }
    
    /**
     * Defines and returns arrays containing the pixel index value inside the 
     * image (from left-to-right, top-to-bottom, starting from zero), based on 
     * its XY position, for each of the ship's filled sections.
     * 
     * The array's index are:
     * - 0: Solid cell array;
     * - 1: Body cell array;
     * - 2: Cockpit cell array;
     * 
     * @return array
     */
    private function cellValues() 
    {
        // Defining solid cell array
        $solid = array(
            $this->cell(5,  2), $this->cell(5,  3), $this->cell(5,  4), 
            $this->cell(5,  5), $this->cell(5,  9)
        );
        // Defining body cell array
        $shape = array(
            $this->cell(4,  1), $this->cell(5,  1), $this->cell(4,  2), 
            $this->cell(3,  3), $this->cell(4,  3), $this->cell(3,  4), 
            $this->cell(4,  4), $this->cell(2,  5), $this->cell(3,  5), 
            $this->cell(4,  5), $this->cell(1,  6), $this->cell(2,  6), 
            $this->cell(3,  6), $this->cell(1,  7), $this->cell(2,  7), 
            $this->cell(3,  7), $this->cell(1,  8), $this->cell(2,  8), 
            $this->cell(3,  8), $this->cell(1,  9), $this->cell(2,  9), 
            $this->cell(3,  9), $this->cell(4,  9), $this->cell(3, 10), 
            $this->cell(4, 10), $this->cell(5, 10)
        );
        // Defining cockpit cell array
        $cabin = array(
            $this->cell(4,  6), $this->cell(5,  6), $this->cell(4,  7), 
            $this->cell(5,  7), $this->cell(4,  8)
        );
        // Returning arrays
        return array($solid, $shape, $cabin);
    }
    
    /**
     * Generates the seeds for defining the ship's shape and color.
     * 
     * It tries to use something similar to the original script's seed generator 
     * or, if desired, a smaller seed.
     * 
     * @return int
     */
    private function generateSeed() 
    {
        // Checking if using smaller seeds
        if (!$this->original) return rand(0, 32768);
        // If using the "original" seed
        // Generating random float
        $rand = (float) rand() / (float) getrandmax();
        // Returning
        return floor($rand * 4 * 1024 * 1024 * 1024);
    }
}