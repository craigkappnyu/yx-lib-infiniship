/**
 * InfiniShip | Processing (2.0) :: A procedural spaceship generator
 * ======================================================================
 * 
 * This is a remake of Dave Bollinger's "Pixel Spaceships", remade and 
 * commented.
 * 
 * I tried to organize things inside and comment/explain everything, but I'm 
 * a little bit bad with programming so, sorry if I messed up something.
 * 
 * The original script was made for Processing, in 2006, by Dave. But this 
 * version has also used "mtheall" HTML5 Canvas (from 2013) version as reference 
 * for some structure and methods.
 * 
 * This version is intended to work the same way as Bollinger's original script, 
 * but may not do it well, because I didn't replicate his seed generator in this 
 * one.
 * 
 * NOTE: Some of the creative output (images) generated by this script remains 
 * property of Dave Bollinger, as this script follows his basic concept. Even 
 * though the possible combination of ships is huge, Dave still has copyright 
 * over his artistic output, so use this carefully.
 * 
 * You are welcome (and highly encouraged) to fork, remix, create your 
 * own way to generate sprites and use this as reference to build your own 
 * generator. :)
 * 
 * @author Fabio Y. Goto <lab@yuiti.com.br>
 */

InfiniShip ship;

void setup()
{
    // Screen size, renderer
    size(256, 256, P3D);
    
    // Background color
    background(#ffffff);
    
    // Frame rate ('tis static, is it really needed? :P)
    frameRate(30);
    
    // Executing
    ship = new InfiniShip();
    
    // Printing a demo sprite sheet
    ship.makeMultiple(16, 16);
    
    // Save frame as an image?
    saveFrame("infiniship-####.png");
}

// Main Class
class InfiniShip 
{
    // Empty cell flag
    static final int S_EMPTY = 0;
    
    // Solid cell flag
    static final int S_SOLID = 1;
    
    // Body cell flag
    static final int S_SHAPE = 2;
    
    // Cockpit cell flag
    static final int S_CABIN = 3;
    
    // Ship width
    static final int SHIP_W = 12;
    
    // Ship height
    static final int SHIP_H = 12;
    
    // Pseudo-random integer, to be used a seed when defining the ship's shape.
    int mainseed;
    
    // Pseudo-random integer, to be used a seed when defining the ship's color.
    int clrsseed;
    
    // Solid cell data array
    int[] solidCell = {
        cell(5, 2), cell(5, 3), cell(5, 4), 
        cell(5, 5), cell(5, 9)
    };
    
    // Body cell data array
    int[] shapeCell = {
        cell(4, 1), cell(5, 1), cell(4, 2), cell(3, 3), 
        cell(4, 3), cell(3, 4), cell(4, 4), cell(2, 5), 
        cell(3, 5), cell(4, 5), cell(1, 6), cell(2, 6), 
        cell(3, 6), cell(1, 7), cell(2, 7), cell(3, 7), 
        cell(1, 8), cell(2, 8), cell(3, 8), cell(1, 9), 
        cell(2, 9), cell(3, 9), cell(4, 9), cell(3, 10), 
        cell(4, 10), cell(5, 10)
    };
    
    // Cockpit cell data array
    int[] cabinCell = {
        cell(4, 6), cell(5, 6), cell(4, 7), cell(5, 7), 
        cell(4, 8), cell(5, 8)
    };
    
    // Array to store cell data while building the ship
    int[] ship = new int[SHIP_W * SHIP_H];
    
    // Array containing aturation values
    float[] sats = {
        40, 60, 80, 100, 80, 60, 80, 100, 120, 100, 80, 60
    };
    
    // Brightness values
    float[] bris = {
        40, 70, 100, 130, 160, 190, 220, 220, 190, 160, 130, 100, 70, 40
    };
    
    // Main Constructor
    InfiniShip() 
    {
        // Defining seeds
        mainseed = generateSeed();
        clrsseed = generateSeed() / 1024;
    }
    
    // Multiple ships method, with default values
    void makeMultiple() 
    {
        makeMultiple(8, 8);
    }
    
    // Generates multiple ships. You can decide how many on horizontal and vertical.
    void makeMultiple(int numX, int numY) 
    {
        // Defining initial offset values
        int posX = 0;
        int posY = 0;
        // Redefining quantities
        for (int y = 0; y < numY; y++) {
            for (int x = 0; x < numX; x++) {
                // Printing ship
                generateSingle(posX, posY);
                // Regenerating seeds
                mainseed = generateSeed();
                clrsseed = generateSeed() / 1024;
                println(mainseed);
                // Clear ship array
                ship = new int[SHIP_W * SHIP_H];
                // Increase posX
                posX += 16;
            }
            // Reset posX after loop
            posX = 0;
            // Increase posY
            posY += 16;
        }
    }
    
    // Default generator, places the ship 2px from top and left of the canvas.    
    void generateSingle() 
    {
        generateSingle(0, 0);
    }
    
    // Generates a single ship. Offset values used to move the sprite.
    void generateSingle(int offX, int offY) 
    {
        // Marking all cells empty
        for (int i = 0; i < (SHIP_W * SHIP_H); ++i) {
            ship[i] = S_EMPTY;
        }
        
        // Marking solid cells
        for (int i = 0; i < solidCell.length; ++i) {
            ship[solidCell[i]] = S_SOLID;
        }
    
        // Initializing body cells
        for (int i = 0; i < shapeCell.length; ++i) {
            if ((mainseed & (1 << i)) != 0) {
                ship[shapeCell[i]] = S_SHAPE;
            } else {
                ship[shapeCell[i]] = S_EMPTY;
            }
        }
        
        // Initializing cockpit cells
        for (int i = 0; i < cabinCell.length; ++i) {
            if ((mainseed & (1 << (shapeCell.length + i))) != 0) {
                ship[cabinCell[i]] = S_SOLID;
            } else {
                ship[cabinCell[i]] = S_CABIN;
            }
        }
    
        // Defining border
        for (int y = 0; y < SHIP_H; ++y) {
            for (int x = 0; x < SHIP_W / 2; ++x) {
                // If the cell is a body cell
                if (ship[cell(x, y)] == S_SHAPE) {
                    // Bottom
                    if (y > 0 && ship[cell(x, y - 1)] == S_EMPTY) {
                        ship[cell(x, y - 1)] = S_SOLID;
                    }
                    // Left
                    if (x > 0 && ship[cell(x - 1, y)] == S_EMPTY) {
                        ship[cell(x - 1, y)] = S_SOLID;
                    }
                    // Right
                    if (x < (SHIP_W / 2 - 1) && ship[cell(x + 1, y)] == S_EMPTY) {
                        ship[cell(x + 1, y)] = S_SOLID;
                    }
                    // Top
                    if (y < SHIP_H && ship[cell(x, y + 1)] == S_EMPTY) {
                        ship[cell(x, y + 1)] = S_SOLID;
                    }
                }
            }
        }
        
        // Drawing the ship
        for (int y = 0; y < SHIP_H; ++y) {
            for (int x = 0; x < SHIP_W / 2; ++x) {
                noStroke();
                if (ship[cell(x, y)] != S_EMPTY) {
                    switch (ship[cell(x, y)]) {
                        case S_SOLID:
                            fill(#000000);
                            break;
                        case S_SHAPE:
                            // Get color values
                            int[] tint = shapeColor(x, y);
                            // Define fill
                            fill(tint[0], tint[1], tint[2]);
                            break;
                        case S_CABIN:
                            // Get color values
                            int[] cols = cabinColor(x, y);
                            // Define fill
                            fill(cols[0], cols[1], cols[2]);
                            break;
                    }
                    // Draw the pixel
                    rect(offX + x + 2, offY + y + 2, 1, 1);
                    // Draw mirrored
                    rect(offX + SHIP_W - (x - 1), offY + y + 2, 1, 1);
                }
            }
        }
    }
    
    // Generates the seeds for defining the ship's shape and color.
    // This one works a little bit differently from the original one. :P
    int generateSeed() 
    {
        float rand = random(0, 1);
        float seed = rand * 4 * 1024 * 1024;
        return floor(seed * ((rand < 0.5) ? -1 : 1));
    }
    
    // Calculates the pixel index value.
    int cell(int x, int y) 
    {
        return (y * SHIP_W) + x;
    }
    
    // Converts the HSV (Hue, Saturation and Brightness) values from a color 
    // into its RGB counterpart, returning them in an array.
    int[] HSVRGB(float h, float s, float v) 
    {
        // If saturation equals zero, returns a shade of gray
        if (s == 0) {
            int[] colors = {
                floor(v * 255), 
                floor(v * 255), 
                floor(v * 255)
            };
            return colors;
        }
        // Color variables
        float r, g, b, i, f, p, q, t;
        // Defining color values
        i = floor(h * 6);
        f = h * 6 - i;
        p = v * (1 - s);
        q = v * (1 - f * s);
        t = v * (1 - (1 - f) * s);
        // Defining final RGB values
        int flag = floor(i % 6);
        switch (flag) {
            case 1:
                r = q;
                g = v;
                b = p;
                break;
            case 2:
                r = p;
                g = v;
                b = t;
                break;
            case 3:
                r = p;
                g = q;
                b = v;
                break;
            case 4:
                r = t;
                g = p;
                b = v;
                break;
            case 5:
                r = v;
                g = p;
                b = q;
                break;
            default:
                r = v;
                g = t;
                b = p;
                break;
        }
        // Returning
        int[] colors = {
            floor(r * 255), 
            floor(g * 255), 
            floor(b * 255) 
        };
        return colors;
    }
    
    // Returns an array, with the RGB values for the colors for a 
    // pixel in the desired coordinates, in the ship's body.
    int[] shapeColor(int x, int y) 
    {
        // Defining saturarion
        float s = sats[y] / 255.0;
        // Defining brightness
        float v = bris[x] / 255.0;
        // Defining hue
        float h;
        if (y < 6) {
            h = (clrsseed >> 8) & 0xff;
        } else if (y < 9) {
            h = (clrsseed >> 16) & 0xff;
        } else {
            h = (clrsseed >> 24) & 0xff;
        }
        // Returning values
        return HSVRGB(360 * h / 256, s, v);
    }
    
    // Returns an array, with the RGB values for the colors for a 
    // pixel in the desired coordinates, in the ship's cockpit.
    int[] cabinColor(int x, int y) 
    {
        // Defining saturarion
        float s = sats[y] / 255.0;
        // Defining brightness
        float v = (bris[x] + 40) / 255.0;
        // Defining hue
        float h = clrsseed & 0xff;
        // Returning values
        return HSVRGB(360 * h / 256, s, v);
    }
}
